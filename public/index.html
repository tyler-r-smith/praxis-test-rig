<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Click Box Game</title>
  <style>
    :root {
      --bg-gradient-start: #1a1a2e;
      --bg-gradient-end: #16213e;
      --header-bg: rgba(0, 0, 0, 0.4);
      --header-border: rgba(255, 255, 255, 0.15);
      --ui-bg: rgba(255, 255, 255, 0.1);
      --text-color: white;
      --text-muted: rgba(255, 255, 255, 0.7);
      --overlay-bg: rgba(0, 0, 0, 0.8);
      --input-border: rgba(255, 255, 255, 0.3);
      --input-bg: rgba(255, 255, 255, 0.1);
      --input-text: white;
      --input-placeholder: rgba(255, 255, 255, 0.5);
      --scores-border: rgba(255, 255, 255, 0.1);
      --box-text-shadow: 0 2px 4px rgba(0,0,0,0.3);
      --box-shadow: 0 5px 20px rgba(0,0,0,0.3);
    }

    [data-theme="light"] {
      --bg-gradient-start: #e8f4f8;
      --bg-gradient-end: #d4e5ed;
      --header-bg: rgba(255, 255, 255, 0.8);
      --header-border: rgba(0, 0, 0, 0.1);
      --ui-bg: rgba(0, 0, 0, 0.05);
      --text-color: #1a1a2e;
      --text-muted: rgba(0, 0, 0, 0.6);
      --overlay-bg: rgba(255, 255, 255, 0.95);
      --input-border: rgba(0, 0, 0, 0.2);
      --input-bg: rgba(0, 0, 0, 0.05);
      --input-text: #1a1a2e;
      --input-placeholder: rgba(0, 0, 0, 0.4);
      --scores-border: rgba(0, 0, 0, 0.1);
      --box-text-shadow: 0 2px 4px rgba(0,0,0,0.2);
      --box-shadow: 0 5px 20px rgba(0,0,0,0.15);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      position: relative;
      background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    #header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 100px;
      background: var(--header-bg);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 150;
      border-bottom: 2px solid var(--header-border);
    }
    #header h2 {
      font-size: 42px;
      font-weight: bold;
      background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      letter-spacing: 4px;
      text-transform: uppercase;
    }
    #header-score {
      position: absolute;
      right: 30px;
      color: #4ECDC4;
      font-size: 24px;
      font-weight: bold;
    }
    #game-ui {
      position: fixed;
      top: 120px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 30px;
      z-index: 100;
      background: var(--ui-bg);
      padding: 15px 30px;
      border-radius: 15px;
      backdrop-filter: blur(10px);
    }
    .stat {
      text-align: center;
      color: var(--text-color);
    }
    .stat-label {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: var(--text-muted);
    }
    .stat-value {
      font-size: 32px;
      font-weight: bold;
    }
    #score-value {
      color: #4ECDC4;
    }
    #time-value {
      color: #FF6B6B;
    }
    #start-screen, #game-over-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: var(--overlay-bg);
      z-index: 200;
      color: var(--text-color);
    }
    #game-over-screen {
      display: none;
    }
    h1 {
      font-size: 48px;
      margin-bottom: 20px;
      background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .subtitle {
      font-size: 18px;
      color: var(--text-muted);
      margin-bottom: 40px;
    }
    #final-score {
      font-size: 72px;
      color: #4ECDC4;
      margin: 20px 0;
    }
    .new-high-score {
      color: #FFD700;
      font-size: 36px;
      animation: glow 0.4s ease-in-out infinite alternate;
      margin-bottom: 20px;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 3px;
    }
    @keyframes glow {
      from { text-shadow: 0 0 20px rgba(255, 215, 0, 0.6), 0 0 40px rgba(255, 215, 0, 0.3); }
      to { text-shadow: 0 0 50px rgba(255, 215, 0, 1), 0 0 80px rgba(255, 215, 0, 0.6), 0 0 100px rgba(255, 215, 0, 0.3); }
    }
    .high-scores {
      margin-top: 30px;
      background: var(--ui-bg);
      padding: 20px 40px;
      border-radius: 15px;
    }
    .high-scores h3 {
      color: #FFD700;
      margin-bottom: 15px;
    }
    .high-scores ol {
      list-style: none;
      padding: 0;
    }
    .high-scores li {
      padding: 8px 0;
      font-size: 18px;
      border-bottom: 1px solid var(--scores-border);
    }
    .high-scores li:last-child {
      border-bottom: none;
    }
    .high-scores li.current {
      color: #4ECDC4;
      font-weight: bold;
    }
    .name-input-container {
      margin: 20px 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    .name-input-container label {
      font-size: 16px;
      color: var(--text-muted);
    }
    #player-name {
      padding: 12px 20px;
      font-size: 18px;
      border: 2px solid var(--input-border);
      border-radius: 10px;
      background: var(--input-bg);
      color: var(--input-text);
      text-align: center;
      width: 200px;
      outline: none;
      transition: border-color 0.2s;
    }
    #player-name:focus {
      border-color: #4ECDC4;
    }
    #player-name::placeholder {
      color: var(--input-placeholder);
    }
    .high-scores .score-name {
      color: #FFD700;
    }
    .high-scores .score-value {
      color: #4ECDC4;
      float: right;
    }
    .high-scores-animate li {
      animation: slideIn 0.3s ease-out backwards;
    }
    .high-scores-animate li:nth-child(1) { animation-delay: 0.1s; }
    .high-scores-animate li:nth-child(2) { animation-delay: 0.15s; }
    .high-scores-animate li:nth-child(3) { animation-delay: 0.2s; }
    .high-scores-animate li:nth-child(4) { animation-delay: 0.25s; }
    .high-scores-animate li:nth-child(5) { animation-delay: 0.3s; }
    .high-scores-animate li:nth-child(6) { animation-delay: 0.35s; }
    .high-scores-animate li:nth-child(7) { animation-delay: 0.4s; }
    .high-scores-animate li:nth-child(8) { animation-delay: 0.45s; }
    .high-scores-animate li:nth-child(9) { animation-delay: 0.5s; }
    .high-scores-animate li:nth-child(10) { animation-delay: 0.55s; }
    @keyframes slideIn {
      from { transform: translateX(-20px); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    button {
      padding: 15px 50px;
      font-size: 20px;
      border: none;
      border-radius: 30px;
      cursor: pointer;
      background: linear-gradient(45deg, #FF6B6B, #FF8E8E);
      color: white;
      font-weight: bold;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    button:hover {
      transform: scale(1.05);
      box-shadow: 0 10px 30px rgba(255, 107, 107, 0.4);
    }
    .click-box {
      position: absolute;
      border-radius: 12px;
      cursor: pointer;
      transition: transform 0.1s ease;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      color: white;
      text-shadow: var(--box-text-shadow);
      box-shadow: var(--box-shadow);
    }
    .click-box.shape-circle {
      border-radius: 50%;
    }
    .click-box.shape-square {
      border-radius: 8px;
    }
    .click-box.shape-tall {
      border-radius: 16px;
    }
    .click-box.shape-wide {
      border-radius: 16px;
    }
    .click-box.shape-diamond {
      border-radius: 4px;
      transform: rotate(45deg);
    }
    .click-box.shape-diamond:hover {
      transform: rotate(45deg) scale(1.1);
    }
    .click-box.shape-diamond .box-text {
      transform: rotate(-45deg);
    }
    .click-box:hover {
      transform: scale(1.1);
    }
    .click-box.moving {
      transition: left 0.1s linear, top 0.1s linear, width 0.3s ease, height 0.3s ease, font-size 0.3s ease;
    }
    .click-box.moving:hover {
      transform: scale(1.1);
    }
    .click-box.clicked {
      animation: pop 0.3s ease-out forwards;
    }
    @keyframes pop {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.3); }
      100% { transform: scale(0); opacity: 0; }
    }
    .bonus-box {
      animation: pulse 0.5s ease-in-out infinite alternate;
    }
    @keyframes pulse {
      from { box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
      to { box-shadow: 0 0 40px rgba(255, 215, 0, 0.9); }
    }
    .obstacle-box {
      background: linear-gradient(135deg, #2c0a0a 0%, #5c1a1a 50%, #8b0000 100%) !important;
      border: 3px solid #ff4444;
      animation: dangerPulse 0.4s ease-in-out infinite alternate;
    }
    @keyframes dangerPulse {
      from { box-shadow: 0 0 15px rgba(255, 0, 0, 0.5), inset 0 0 10px rgba(255, 68, 68, 0.3); }
      to { box-shadow: 0 0 30px rgba(255, 0, 0, 0.8), inset 0 0 20px rgba(255, 68, 68, 0.5); }
    }
    .obstacle-box:hover {
      transform: scale(1.1);
      border-color: #ff6666;
    }
    .obstacle-box.clicked {
      animation: explode 0.4s ease-out forwards;
    }
    @keyframes explode {
      0% { transform: scale(1); opacity: 1; }
      30% { transform: scale(1.5); background: #ff4444; }
      100% { transform: scale(0); opacity: 0; }
    }
    /* High Score Celebration Animations */
    @keyframes confettiFall {
      0% {
        transform: translateY(0) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translateY(100vh) rotate(720deg);
        opacity: 0;
      }
    }
    @keyframes scoreBounce {
      0%, 100% { transform: scale(1); }
      25% { transform: scale(1.8); }
      50% { transform: scale(1.2); }
      75% { transform: scale(1.5); }
    }
    @keyframes highScoreEntrance {
      0% {
        transform: scale(0) rotate(-180deg);
        opacity: 0;
      }
      40% {
        transform: scale(2.5) rotate(15deg);
      }
      70% {
        transform: scale(1.8) rotate(-5deg);
      }
      100% {
        transform: scale(1) rotate(0deg);
        opacity: 1;
      }
    }
    @keyframes starBurst {
      0% {
        transform: scale(0) rotate(0deg);
        opacity: 1;
      }
      50% {
        transform: scale(2.5) rotate(180deg);
        opacity: 0.9;
      }
      100% {
        transform: scale(0) rotate(360deg);
        opacity: 0;
      }
    }
    .confetti {
      position: fixed;
      width: 20px;
      height: 20px;
      z-index: 250;
      pointer-events: none;
    }
    .confetti.shape-square {
      border-radius: 4px;
    }
    .confetti.shape-circle {
      border-radius: 50%;
    }
    .confetti.shape-ribbon {
      width: 8px;
      height: 32px;
      border-radius: 4px;
    }
    .score-celebrate {
      animation: scoreBounce 1.2s ease-out;
    }
    .new-high-score.celebrate {
      animation: highScoreEntrance 0.8s ease-out, glow 0.5s ease-in-out infinite alternate 0.8s;
    }
    .celebration-star {
      position: fixed;
      font-size: 60px;
      z-index: 250;
      pointer-events: none;
      animation: starBurst 1.2s ease-out forwards;
    }
    #theme-toggle {
      position: absolute;
      left: 20px;
      background: var(--ui-bg);
      border: 1px solid var(--header-border);
      border-radius: 20px;
      padding: 8px 16px;
      cursor: pointer;
      font-size: 14px;
      color: var(--text-color);
      transition: background 0.2s, transform 0.2s;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    #theme-toggle:hover {
      transform: scale(1.05);
      background: var(--input-bg);
    }
    .theme-icon {
      font-size: 16px;
    }
    /* Creature styles */
    .creature {
      position: absolute;
      z-index: 50;
      pointer-events: auto;
      cursor: pointer;
      font-size: 48px;
      transition: transform 0.1s ease;
    }
    .creature:hover {
      transform: scale(1.2);
    }
    .creature.clicked {
      animation: creatureExplode 0.3s ease-out forwards;
    }
    @keyframes creatureExplode {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.5); }
      100% { transform: scale(0); opacity: 0; }
    }
    .creature.walking {
      animation: creatureWalk 0.3s ease-in-out infinite;
    }
    .creature.carrying {
      animation: creatureCarry 0.2s ease-in-out infinite;
    }
    .creature.facing-left {
      transform: scaleX(-1);
    }
    .creature.facing-left.walking {
      animation: creatureWalkFlipped 0.3s ease-in-out infinite;
    }
    .creature.facing-left.carrying {
      animation: creatureCarryFlipped 0.2s ease-in-out infinite;
    }
    @keyframes creatureWalk {
      0%, 100% { transform: translateY(0) rotate(-5deg); }
      50% { transform: translateY(-8px) rotate(5deg); }
    }
    @keyframes creatureWalkFlipped {
      0%, 100% { transform: scaleX(-1) translateY(0) rotate(-5deg); }
      50% { transform: scaleX(-1) translateY(-8px) rotate(5deg); }
    }
    @keyframes creatureCarry {
      0%, 100% { transform: translateY(0) rotate(-3deg) scale(1.1); }
      50% { transform: translateY(-5px) rotate(3deg) scale(1.1); }
    }
    @keyframes creatureCarryFlipped {
      0%, 100% { transform: scaleX(-1) translateY(0) rotate(-3deg) scale(1.1); }
      50% { transform: scaleX(-1) translateY(-5px) rotate(3deg) scale(1.1); }
    }
    .stolen-points {
      position: absolute;
      font-size: 18px;
      font-weight: bold;
      color: #FF6B6B;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
      pointer-events: none;
      animation: stolenFloat 1s ease-out forwards;
    }
    @keyframes stolenFloat {
      0% { opacity: 1; transform: translateY(0); }
      100% { opacity: 0; transform: translateY(-30px); }
    }
    /* Chicken styles - floats above everything */
    .chicken {
      position: fixed;
      z-index: 300;
      font-size: 64px;
      cursor: not-allowed;
      pointer-events: auto;
      user-select: none;
      filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
      transition: transform 0.1s ease;
    }
    .chicken:hover {
      transform: scale(1.1);
    }
    .chicken.floating {
      animation: chickenFloat 2s ease-in-out infinite;
    }
    @keyframes chickenFloat {
      0%, 100% { transform: translateY(0) rotate(-3deg); }
      50% { transform: translateY(-15px) rotate(3deg); }
    }
    .chicken.blocking {
      animation: chickenBlock 0.5s ease-in-out infinite;
    }
    @keyframes chickenBlock {
      0%, 100% { transform: scale(1) rotate(-5deg); }
      50% { transform: scale(1.15) rotate(5deg); }
    }
  </style>
</head>
<body>
  <header id="header">
    <button id="theme-toggle" aria-label="Toggle theme">
      <span class="theme-icon">üåô</span>
      <span class="theme-label">Dark</span>
    </button>
    <h2>CLICK BOX</h2>
    <div id="header-score">Score: <span id="header-score-value">10</span></div>
  </header>

  <div id="game-ui">
    <div class="stat">
      <div class="stat-label">Score</div>
      <div class="stat-value" id="score-value">10</div>
    </div>
    <div class="stat">
      <div class="stat-label">Time</div>
      <div class="stat-value" id="time-value">30</div>
    </div>
  </div>

  <div id="start-screen">
    <h1>Click Box Game</h1>
    <p class="subtitle">Click the boxes before they disappear!</p>
    <button id="start-btn">Start Game</button>
    <div id="start-high-scores" class="high-scores" style="display: none;"></div>
  </div>

  <div id="game-over-screen">
    <h1>Game Over!</h1>
    <p class="subtitle">Your Score</p>
    <div id="final-score">0</div>
    <div id="new-high-score" class="new-high-score" style="display: none;">New High Score!</div>
    <div class="name-input-container">
      <label for="player-name">Enter your name:</label>
      <input type="text" id="player-name" placeholder="Anonymous" maxlength="15">
    </div>
    <button id="restart-btn">Play Again</button>
    <div id="end-high-scores" class="high-scores high-scores-animate"></div>
  </div>

  <script>
    const colors = [
      '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4',
      '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F',
      '#BB8FCE', '#85C1E9', '#F8B500', '#FF6F61'
    ];

    let score = 10;
    let timeLeft = 30;
    let gameInterval;
    let spawnInterval;
    let obstacleInterval;
    let creatureInterval;
    let isPlaying = false;
    let highScores = loadHighScores();

    const creatureEmojis = ['üêÄ', 'üêÅ', 'üêøÔ∏è', 'ü¶ù', 'üêí', 'ü¶ä'];
    const creatures = [];

    function loadHighScores() {
      const stored = JSON.parse(localStorage.getItem('clickBoxHighScores')) || [];
      // Migrate old format (numbers) to new format (objects with name and score)
      return stored.map(entry => {
        if (typeof entry === 'number') {
          return { name: 'Anonymous', score: entry };
        }
        return entry;
      });
    }

    function getHighScore() {
      return highScores.length > 0 ? highScores[0].score : 0;
    }

    function updateHighScores(newScore, playerName) {
      const name = playerName && playerName.trim() ? playerName.trim() : 'Anonymous';
      highScores.push({ name: name, score: newScore });
      highScores.sort((a, b) => b.score - a.score);
      highScores = highScores.slice(0, 10);
      localStorage.setItem('clickBoxHighScores', JSON.stringify(highScores));
    }

    function renderHighScores(containerId, currentScore = null) {
      const container = document.getElementById(containerId);
      if (highScores.length === 0) {
        container.style.display = 'none';
        return;
      }
      container.style.display = 'block';
      let html = '<h3>High Scores</h3><ol>';
      highScores.forEach((entry, i) => {
        const isCurrent = currentScore !== null && entry.score === currentScore;
        html += '<li class="' + (isCurrent ? 'current' : '') + '">#' + (i + 1) + ': <span class="score-name">' + escapeHtml(entry.name) + '</span> <span class="score-value">' + entry.score + '</span></li>';
      });
      html += '</ol>';
      container.innerHTML = html;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    const scoreDisplay = document.getElementById('score-value');
    const headerScoreDisplay = document.getElementById('header-score-value');
    const timeDisplay = document.getElementById('time-value');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const finalScoreDisplay = document.getElementById('final-score');

    function updateScoreDisplay() {
      scoreDisplay.textContent = score;
      headerScoreDisplay.textContent = score;
    }

    function randomColor() {
      return colors[Math.floor(Math.random() * colors.length)];
    }

    const shapes = ['square', 'circle', 'tall', 'wide', 'diamond'];

    function createBox() {
      if (!isPlaying) return;

      const box = document.createElement('div');
      box.className = 'click-box';

      const isBonus = Math.random() < 0.1;
      const shape = shapes[Math.floor(Math.random() * shapes.length)];
      box.classList.add('shape-' + shape);

      let width, height;
      if (isBonus) {
        width = height = 40;
      } else {
        const baseSize = Math.floor(Math.random() * 50) + 40;
        switch (shape) {
          case 'tall':
            width = baseSize;
            height = baseSize * (1.5 + Math.random() * 0.5);
            break;
          case 'wide':
            width = baseSize * (1.5 + Math.random() * 0.5);
            height = baseSize;
            break;
          case 'diamond':
            width = height = baseSize * 0.8;
            break;
          default:
            width = height = baseSize;
        }
      }

      // Determine if this box moves and/or changes size
      const isMoving = !isBonus && Math.random() < 0.4;
      const isResizing = !isBonus && Math.random() < 0.3;

      // Speed: 1-5 (higher = faster movement)
      const speed = isMoving ? Math.floor(Math.random() * 5) + 1 : 0;

      // Calculate points with high variation
      // Base: 5-15 points randomly
      const basePoints = Math.floor(Math.random() * 11) + 5;
      // Size bonus: Smaller boxes = more points (0-20 range)
      const sizeBonus = Math.floor((100 - Math.min(width, height)) / 3);
      // Speed bonus: Faster = more points (0-15 range)
      const speedBonus = speed * 3;
      // Shape bonus: Harder shapes get bonus points
      const shapeBonus = (shape === 'diamond') ? 10 : (shape === 'circle') ? 5 : 0;
      // Rare multiplier: 10% chance for 2x, 2% chance for 3x
      const rareRoll = Math.random();
      const rareMultiplier = rareRoll < 0.02 ? 3 : (rareRoll < 0.12 ? 2 : 1);
      // Calculate final points (range: ~5 to 80+)
      let points = isBonus ? 50 : Math.floor((basePoints + sizeBonus + speedBonus + shapeBonus) * rareMultiplier);

      const maxX = window.innerWidth - width - 20;
      const maxY = window.innerHeight - height - 100;
      let x = Math.floor(Math.random() * Math.max(maxX, 10)) + 10;
      let y = Math.floor(Math.random() * Math.max(maxY - 120, 10)) + 120;

      box.style.width = width + 'px';
      box.style.height = height + 'px';
      box.style.left = x + 'px';
      box.style.top = y + 'px';
      box.style.backgroundColor = isBonus ? '#FFD700' : randomColor();

      if (isMoving) {
        box.classList.add('moving');
      }

      const updatePointsDisplay = () => {
        if (shape === 'diamond') {
          const textSpan = box.querySelector('.box-text');
          if (textSpan) textSpan.textContent = '+' + points;
        } else {
          box.textContent = '+' + points;
        }
      };

      if (shape === 'diamond') {
        const textSpan = document.createElement('span');
        textSpan.className = 'box-text';
        textSpan.textContent = '+' + points;
        box.appendChild(textSpan);
      } else {
        box.textContent = '+' + points;
      }
      box.style.fontSize = (Math.min(width, height) / 3) + 'px';

      if (isBonus) {
        box.classList.add('bonus-box');
      }

      // Movement logic
      let moveInterval = null;
      let dx = (Math.random() - 0.5) * speed * 4;
      let dy = (Math.random() - 0.5) * speed * 4;

      if (isMoving) {
        moveInterval = setInterval(() => {
          if (!box.parentNode || box.classList.contains('clicked')) {
            clearInterval(moveInterval);
            return;
          }

          x += dx;
          y += dy;

          // Bounce off walls
          const currentWidth = parseFloat(box.style.width);
          const currentHeight = parseFloat(box.style.height);
          if (x <= 10 || x >= window.innerWidth - currentWidth - 20) {
            dx = -dx;
            x = Math.max(10, Math.min(x, window.innerWidth - currentWidth - 20));
          }
          if (y <= 120 || y >= window.innerHeight - currentHeight - 100) {
            dy = -dy;
            y = Math.max(120, Math.min(y, window.innerHeight - currentHeight - 100));
          }

          box.style.left = x + 'px';
          box.style.top = y + 'px';
        }, 50);
      }

      // Size changing logic
      let resizeInterval = null;
      let currentSize = Math.min(width, height);
      let growing = Math.random() < 0.5;
      const minSize = 30;
      const maxSize = 100;

      if (isResizing) {
        resizeInterval = setInterval(() => {
          if (!box.parentNode || box.classList.contains('clicked')) {
            clearInterval(resizeInterval);
            return;
          }

          // Change size
          if (growing) {
            currentSize += 2;
            if (currentSize >= maxSize) growing = false;
          } else {
            currentSize -= 2;
            if (currentSize <= minSize) growing = true;
          }

          // Update dimensions based on shape
          let newWidth, newHeight;
          if (shape === 'tall') {
            newWidth = currentSize;
            newHeight = currentSize * 1.75;
          } else if (shape === 'wide') {
            newWidth = currentSize * 1.75;
            newHeight = currentSize;
          } else {
            newWidth = currentSize;
            newHeight = currentSize;
          }

          box.style.width = newWidth + 'px';
          box.style.height = newHeight + 'px';
          box.style.fontSize = (Math.min(newWidth, newHeight) / 3) + 'px';

          // Recalculate points based on current size (keeps base, shape, and rare from initial calc)
          const newSizeBonus = Math.floor((100 - currentSize) / 3);
          points = Math.floor((basePoints + newSizeBonus + speedBonus + shapeBonus) * rareMultiplier);
          updatePointsDisplay();
        }, 100);
      }

      box.addEventListener('click', function() {
        if (this.classList.contains('clicked')) return;
        this.classList.add('clicked');
        if (moveInterval) clearInterval(moveInterval);
        if (resizeInterval) clearInterval(resizeInterval);
        score += points;
        updateScoreDisplay();
        setTimeout(() => this.remove(), 300);
        createBox();
      });

      document.body.appendChild(box);

      const lifetime = isBonus ? 1500 : Math.random() * 2000 + 1500;
      setTimeout(() => {
        if (box.parentNode && !box.classList.contains('clicked')) {
          box.classList.add('clicked');
          setTimeout(() => box.remove(), 300);
        }
      }, lifetime);
    }

    function createObstacle() {
      if (!isPlaying) return;

      const box = document.createElement('div');
      box.className = 'click-box obstacle-box';

      const shape = shapes[Math.floor(Math.random() * shapes.length)];
      box.classList.add('shape-' + shape);

      const baseSize = Math.floor(Math.random() * 40) + 35;
      let width, height;

      switch (shape) {
        case 'tall':
          width = baseSize;
          height = baseSize * (1.5 + Math.random() * 0.5);
          break;
        case 'wide':
          width = baseSize * (1.5 + Math.random() * 0.5);
          height = baseSize;
          break;
        case 'diamond':
          width = height = baseSize * 0.8;
          break;
        default:
          width = height = baseSize;
      }

      const penalty = Math.floor(Math.random() * 6) + 5;

      const maxX = window.innerWidth - width - 20;
      const maxY = window.innerHeight - height - 100;
      const x = Math.floor(Math.random() * Math.max(maxX, 10)) + 10;
      const y = Math.floor(Math.random() * Math.max(maxY - 120, 10)) + 120;

      box.style.width = width + 'px';
      box.style.height = height + 'px';
      box.style.left = x + 'px';
      box.style.top = y + 'px';

      if (shape === 'diamond') {
        const textSpan = document.createElement('span');
        textSpan.className = 'box-text';
        textSpan.textContent = '-' + penalty;
        box.appendChild(textSpan);
      } else {
        box.textContent = '-' + penalty;
      }
      box.style.fontSize = (Math.min(width, height) / 3) + 'px';

      box.addEventListener('click', function() {
        if (this.classList.contains('clicked')) return;
        this.classList.add('clicked');
        score -= penalty;
        updateScoreDisplay();
        if (score <= 0) {
          endGame();
        }
        setTimeout(() => this.remove(), 400);
      });

      document.body.appendChild(box);

      const lifetime = Math.random() * 2500 + 2000;
      setTimeout(() => {
        if (box.parentNode && !box.classList.contains('clicked')) {
          box.classList.add('clicked');
          setTimeout(() => box.remove(), 400);
        }
      }, lifetime);
    }

    function createCreature() {
      if (!isPlaying) return;

      const creature = document.createElement('div');
      creature.className = 'creature walking';
      creature.textContent = creatureEmojis[Math.floor(Math.random() * creatureEmojis.length)];

      // Decide which side to enter from
      const enterFromLeft = Math.random() < 0.5;
      const speed = 2 + Math.random() * 3; // pixels per frame

      // Position creature
      const y = Math.floor(Math.random() * (window.innerHeight - 200)) + 150;
      let x = enterFromLeft ? -60 : window.innerWidth + 10;

      creature.style.left = x + 'px';
      creature.style.top = y + 'px';

      if (!enterFromLeft) {
        creature.classList.add('facing-left');
      }

      // Click handler - creature acts as bomb, subtracts 1 point
      creature.addEventListener('click', function() {
        if (this.classList.contains('clicked')) return;
        this.classList.add('clicked');
        score -= 1;
        updateScoreDisplay();

        // Show -1 indicator
        const pointsDisplay = document.createElement('div');
        pointsDisplay.className = 'stolen-points';
        pointsDisplay.textContent = '-1';
        pointsDisplay.style.left = (parseFloat(this.style.left) + 20) + 'px';
        pointsDisplay.style.top = (parseFloat(this.style.top) - 20) + 'px';
        document.body.appendChild(pointsDisplay);
        setTimeout(() => pointsDisplay.remove(), 1000);

        // Check for game over
        if (score <= 0) {
          endGame();
        }

        // Remove creature after animation
        setTimeout(() => {
          this.remove();
          const idx = creatures.findIndex(c => c.element === this);
          if (idx > -1) creatures.splice(idx, 1);
        }, 300);
      });

      document.body.appendChild(creature);

      const creatureData = {
        element: creature,
        x: x,
        y: y,
        speed: speed,
        enterFromLeft: enterFromLeft,
        targetBox: null,
        carriedBox: null,
        hasStolen: false,
        returning: false
      };
      creatures.push(creatureData);

      // Find nearest non-obstacle box
      function findNearestBox() {
        const boxes = document.querySelectorAll('.click-box:not(.obstacle-box):not(.clicked)');
        let nearest = null;
        let nearestDist = Infinity;

        boxes.forEach(box => {
          const boxX = parseFloat(box.style.left) + parseFloat(box.style.width) / 2;
          const boxY = parseFloat(box.style.top) + parseFloat(box.style.height) / 2;
          const dist = Math.sqrt((boxX - creatureData.x) ** 2 + (boxY - creatureData.y) ** 2);

          if (dist < nearestDist) {
            nearestDist = dist;
            nearest = box;
          }
        });

        return nearest;
      }

      const moveCreature = () => {
        if (!creature.parentNode || !isPlaying || creature.classList.contains('clicked')) {
          const idx = creatures.indexOf(creatureData);
          if (idx > -1) creatures.splice(idx, 1);
          return;
        }

        // If returning with stolen box, head to exit
        if (creatureData.returning) {
          const exitX = creatureData.enterFromLeft ? -80 : window.innerWidth + 80;
          const dx = exitX - creatureData.x;
          const moveX = Math.sign(dx) * Math.min(Math.abs(dx), creatureData.speed);

          creatureData.x += moveX;
          creature.style.left = creatureData.x + 'px';

          // Update facing direction
          if (moveX < 0 && !creature.classList.contains('facing-left')) {
            creature.classList.add('facing-left');
          } else if (moveX > 0 && creature.classList.contains('facing-left')) {
            creature.classList.remove('facing-left');
          }

          // Move carried box with creature
          if (creatureData.carriedBox && creatureData.carriedBox.parentNode) {
            creatureData.carriedBox.style.left = (creatureData.x - 10) + 'px';
            creatureData.carriedBox.style.top = (creatureData.y - 30) + 'px';
          }

          // Check if exited
          const exited = creatureData.enterFromLeft ?
            creatureData.x < -60 :
            creatureData.x > window.innerWidth + 60;

          if (exited) {
            // Remove carried box
            if (creatureData.carriedBox && creatureData.carriedBox.parentNode) {
              creatureData.carriedBox.remove();
            }
            creature.remove();
            const idx = creatures.indexOf(creatureData);
            if (idx > -1) creatures.splice(idx, 1);
            return;
          }

          requestAnimationFrame(moveCreature);
          return;
        }

        // Find a target box if we don't have one
        if (!creatureData.targetBox || !creatureData.targetBox.parentNode || creatureData.targetBox.classList.contains('clicked')) {
          creatureData.targetBox = findNearestBox();
        }

        // If no boxes available, just walk across and exit
        if (!creatureData.targetBox) {
          const exitX = creatureData.enterFromLeft ? window.innerWidth + 80 : -80;
          const dx = exitX - creatureData.x;
          const moveX = Math.sign(dx) * Math.min(Math.abs(dx), creatureData.speed);

          creatureData.x += moveX;
          creature.style.left = creatureData.x + 'px';

          // Update facing direction
          if (moveX < 0 && !creature.classList.contains('facing-left')) {
            creature.classList.add('facing-left');
          } else if (moveX > 0 && creature.classList.contains('facing-left')) {
            creature.classList.remove('facing-left');
          }

          const exited = creatureData.enterFromLeft ?
            creatureData.x > window.innerWidth + 60 :
            creatureData.x < -60;

          if (exited) {
            creature.remove();
            const idx = creatures.indexOf(creatureData);
            if (idx > -1) creatures.splice(idx, 1);
            return;
          }

          requestAnimationFrame(moveCreature);
          return;
        }

        // Move toward target box
        const box = creatureData.targetBox;
        const boxX = parseFloat(box.style.left) + parseFloat(box.style.width) / 2;
        const boxY = parseFloat(box.style.top) + parseFloat(box.style.height) / 2;

        const dx = boxX - creatureData.x;
        const dy = boxY - creatureData.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        // Check if we reached the box
        if (dist < 40) {
          // Steal the box!
          creature.classList.remove('walking');
          creature.classList.add('carrying');
          creatureData.hasStolen = true;
          creatureData.returning = true;

          // Get box point value
          const boxText = box.querySelector('.box-text')?.textContent || box.textContent;
          const points = parseInt(boxText.replace('+', '')) || 10;

          // Mark box as clicked so it can't be clicked
          box.classList.add('clicked');

          // Shrink the box and attach to creature
          box.style.transition = 'all 0.2s ease';
          box.style.width = '25px';
          box.style.height = '25px';
          box.style.fontSize = '8px';
          box.style.left = (creatureData.x - 10) + 'px';
          box.style.top = (creatureData.y - 30) + 'px';
          box.style.zIndex = '51';
          creatureData.carriedBox = box;

          // Deduct points from score
          score -= points;
          updateScoreDisplay();

          // Show stolen points indicator
          const stolenDisplay = document.createElement('div');
          stolenDisplay.className = 'stolen-points';
          stolenDisplay.textContent = '-' + points;
          stolenDisplay.style.left = (creatureData.x + 20) + 'px';
          stolenDisplay.style.top = (creatureData.y - 20) + 'px';
          document.body.appendChild(stolenDisplay);
          setTimeout(() => stolenDisplay.remove(), 1000);

          // Check for game over
          if (score <= 0) {
            endGame();
            return;
          }

          requestAnimationFrame(moveCreature);
          return;
        }

        // Move toward box
        const moveX = (dx / dist) * creatureData.speed;
        const moveY = (dy / dist) * creatureData.speed;

        creatureData.x += moveX;
        creatureData.y += moveY;

        creature.style.left = creatureData.x + 'px';
        creature.style.top = creatureData.y + 'px';

        // Update facing direction based on movement
        if (moveX < 0 && !creature.classList.contains('facing-left')) {
          creature.classList.add('facing-left');
        } else if (moveX > 0 && creature.classList.contains('facing-left')) {
          creature.classList.remove('facing-left');
        }

        requestAnimationFrame(moveCreature);
      };

      requestAnimationFrame(moveCreature);
    }

    function startGame() {
      score = 10;
      timeLeft = 30;
      isPlaying = true;
      updateScoreDisplay();
      timeDisplay.textContent = '30';
      startScreen.style.display = 'none';
      gameOverScreen.style.display = 'none';

      document.querySelectorAll('.click-box').forEach(box => box.remove());
      document.querySelectorAll('.creature').forEach(c => c.remove());
      document.querySelectorAll('.stolen-points').forEach(s => s.remove());
      creatures.length = 0;

      gameInterval = setInterval(() => {
        timeLeft--;
        score--;
        timeDisplay.textContent = timeLeft;
        updateScoreDisplay();
        if (timeLeft <= 0 || score <= 0) {
          endGame();
        }
      }, 1000);

      spawnInterval = setInterval(createBox, 400);
      obstacleInterval = setInterval(createObstacle, 1200);
      creatureInterval = setInterval(createCreature, 3000);
      createBox();
    }

    function createConfetti() {
      const confettiColors = ['#FF6B6B', '#4ECDC4', '#FFD700', '#FF8E8E', '#45B7D1', '#DDA0DD', '#F7DC6F'];
      const shapes = ['square', 'circle', 'ribbon'];

      for (let i = 0; i < 100; i++) {
        setTimeout(() => {
          const confetti = document.createElement('div');
          confetti.className = 'confetti shape-' + shapes[Math.floor(Math.random() * shapes.length)];
          confetti.style.backgroundColor = confettiColors[Math.floor(Math.random() * confettiColors.length)];
          confetti.style.left = Math.random() * 100 + 'vw';
          confetti.style.top = '-40px';
          confetti.style.animation = 'confettiFall ' + (2.5 + Math.random() * 2.5) + 's linear forwards';
          confetti.style.animationDelay = Math.random() * 0.8 + 's';
          document.body.appendChild(confetti);

          setTimeout(() => confetti.remove(), 6000);
        }, i * 20);
      }
    }

    function createStars() {
      const starEmojis = ['‚≠ê', '‚ú®', 'üåü', 'üí´', 'üéâ', 'üéä'];
      for (let i = 0; i < 25; i++) {
        setTimeout(() => {
          const star = document.createElement('div');
          star.className = 'celebration-star';
          star.textContent = starEmojis[Math.floor(Math.random() * starEmojis.length)];
          star.style.left = (10 + Math.random() * 80) + 'vw';
          star.style.top = (10 + Math.random() * 80) + 'vh';
          document.body.appendChild(star);

          setTimeout(() => star.remove(), 1500);
        }, i * 80);
      }
    }

    function celebrateHighScore() {
      createConfetti();
      createStars();

      // Add bounce animation to score
      finalScoreDisplay.classList.add('score-celebrate');
      setTimeout(() => finalScoreDisplay.classList.remove('score-celebrate'), 1500);

      // Add entrance animation to high score text
      const highScoreEl = document.getElementById('new-high-score');
      highScoreEl.classList.add('celebrate');
      setTimeout(() => highScoreEl.classList.remove('celebrate'), 1200);
    }

    function endGame() {
      isPlaying = false;
      clearInterval(gameInterval);
      clearInterval(spawnInterval);
      clearInterval(obstacleInterval);
      clearInterval(creatureInterval);

      document.querySelectorAll('.click-box').forEach(box => box.remove());
      document.querySelectorAll('.creature').forEach(c => c.remove());
      document.querySelectorAll('.stolen-points').forEach(s => s.remove());
      creatures.length = 0;

      const isNewHighScore = score > getHighScore();

      finalScoreDisplay.textContent = score;
      document.getElementById('new-high-score').style.display = isNewHighScore ? 'block' : 'none';
      document.getElementById('player-name').value = '';
      gameOverScreen.style.display = 'flex';
      document.getElementById('player-name').focus();

      // Trigger celebration animation for high score
      if (isNewHighScore) {
        celebrateHighScore();
      }

      // Render high scores without the current score yet (will be added on restart)
      renderHighScores('end-high-scores');
    }

    function saveAndRestart() {
      const playerName = document.getElementById('player-name').value;
      const currentScore = parseInt(finalScoreDisplay.textContent);
      updateHighScores(currentScore, playerName);
      startGame();
    }

    document.getElementById('start-btn').addEventListener('click', startGame);
    document.getElementById('restart-btn').addEventListener('click', saveAndRestart);
    document.getElementById('player-name').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        saveAndRestart();
      }
    });

    // Initialize high scores on start screen
    renderHighScores('start-high-scores');

    // Theme switching
    function getStoredTheme() {
      return localStorage.getItem('clickBoxTheme');
    }

    function getSystemTheme() {
      return window.matchMedia('(prefers-color-scheme: light)').matches ? 'light' : 'dark';
    }

    function getCurrentTheme() {
      return getStoredTheme() || getSystemTheme();
    }

    function setTheme(theme) {
      document.documentElement.setAttribute('data-theme', theme);
      localStorage.setItem('clickBoxTheme', theme);
      updateThemeButton(theme);
    }

    function updateThemeButton(theme) {
      const icon = document.querySelector('.theme-icon');
      const label = document.querySelector('.theme-label');
      if (theme === 'light') {
        icon.textContent = '‚òÄÔ∏è';
        label.textContent = 'Light';
      } else {
        icon.textContent = 'üåô';
        label.textContent = 'Dark';
      }
    }

    function toggleTheme() {
      const currentTheme = document.documentElement.getAttribute('data-theme') || getCurrentTheme();
      const newTheme = currentTheme === 'light' ? 'dark' : 'light';
      setTheme(newTheme);
    }

    // Initialize theme on page load
    const initialTheme = getCurrentTheme();
    setTheme(initialTheme);

    // Listen for system theme changes
    window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', (e) => {
      if (!getStoredTheme()) {
        setTheme(e.matches ? 'light' : 'dark');
      }
    });

    document.getElementById('theme-toggle').addEventListener('click', toggleTheme);

    // Chicken that floats above everything and blocks buttons
    const chicken = document.createElement('div');
    chicken.className = 'chicken floating';
    chicken.textContent = 'üêî';
    chicken.style.left = '50%';
    chicken.style.top = '50%';
    document.body.appendChild(chicken);

    let chickenX = window.innerWidth / 2;
    let chickenY = window.innerHeight / 2;
    let targetButton = null;
    let chickenMode = 'wander'; // 'wander' or 'block'

    function getButtons() {
      return [
        document.getElementById('start-btn'),
        document.getElementById('restart-btn'),
        document.getElementById('theme-toggle')
      ].filter(btn => btn && btn.offsetParent !== null);
    }

    function getButtonCenter(btn) {
      const rect = btn.getBoundingClientRect();
      return {
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      };
    }

    function moveChicken() {
      const buttons = getButtons();

      // Every few seconds, pick a new target button if visible
      if (Math.random() < 0.02 && buttons.length > 0) {
        targetButton = buttons[Math.floor(Math.random() * buttons.length)];
        chickenMode = 'block';
        chicken.classList.remove('floating');
        chicken.classList.add('blocking');
      }

      // If in block mode and have a target, move toward the button
      if (chickenMode === 'block' && targetButton && targetButton.offsetParent !== null) {
        const target = getButtonCenter(targetButton);
        const dx = target.x - chickenX;
        const dy = target.y - chickenY;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 5) {
          // Move toward button
          const speed = 4;
          chickenX += (dx / dist) * speed;
          chickenY += (dy / dist) * speed;
        } else {
          // Arrived at button - stay and block
          chickenX = target.x;
          chickenY = target.y;
        }

        // After blocking for a while, go back to wandering
        if (Math.random() < 0.005) {
          chickenMode = 'wander';
          targetButton = null;
          chicken.classList.remove('blocking');
          chicken.classList.add('floating');
        }
      } else {
        // Wander mode - float around randomly
        chickenMode = 'wander';
        chicken.classList.remove('blocking');
        chicken.classList.add('floating');

        chickenX += (Math.random() - 0.5) * 3;
        chickenY += (Math.random() - 0.5) * 3;

        // Keep within bounds
        chickenX = Math.max(50, Math.min(window.innerWidth - 50, chickenX));
        chickenY = Math.max(50, Math.min(window.innerHeight - 50, chickenY));
      }

      chicken.style.left = chickenX + 'px';
      chicken.style.top = chickenY + 'px';
      chicken.style.transform = 'translate(-50%, -50%)';

      requestAnimationFrame(moveChicken);
    }

    // Start the chicken movement
    moveChicken();
  </script>
</body>
</html>
